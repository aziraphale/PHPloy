#! /usr/bin/env php
<?php
/**
 * @todo Document ALL options (some are undocumented)
 * @todo Include class names in debug output (e.g. `PHPloy_File::get()` rather than just `get()`)
 * @todo Get SMB working with usernames/etc.
 * @todo Allow configurable output spam levels
 */
/**
 * PHPloy - A PHP Deployment Script
 *
 * @package PHPloy
 * @author Baki Goxhaj <banago@gmail.com>
 * @author Fadion Dashi <jonidashi@gmail.com>
 * @author Bruno De Barros <bruno@terraduo.com>
 * @link http://wplancer.com
 * @licence MIT Licence
 * @version 1.4.0
 */

/**
 * Run deployment
 */

define('IS_WINDOWS', (stripos(PHP_OS, 'Win') !== false));

if (IS_WINDOWS) {
    define('OUTPUT_SMILE', ':)');
    define('OUTPUT_COFFEE', 'coffee');
    define('OUTPUT_ARROW_UP', "^");
    define('OUTPUT_ARROW_RIGHT', "->");
    define('OUTPUT_CROSS', "X");
    define('OUTPUT_TICK', '/');
    define('OUTPUT_ROLLBACK', '@');
} else {
    define('OUTPUT_SMILE', '☻');
    define('OUTPUT_COFFEE', '☕');
    define('OUTPUT_ARROW_UP', '↑');
    define('OUTPUT_ARROW_RIGHT', '➝');
    define('OUTPUT_CROSS', '✗');
    define('OUTPUT_TICK', '✓');
    define('OUTPUT_ROLLBACK', '⟲');
}

interface PHPloy_protocol
{
    public function connect(array $serverSpec);
    public function pwd();
    public function chdir($dir);
    public function mkdir($name);
    public function ls($dir);
    public function get($remoteFile, $localFile, $binaryTransfer=true);
    public function put($localFile, $remoteFile, $binaryTransfer=true);
    public function delete($remoteFile);
    public function disconnect();
}

class PHPloy_FTP implements PHPloy_protocol
{
    private $connection;

    public function connect(array $serverSpec)
    {
        // Make sure the $path ends with a slash.
        $serverSpec['path'] = rtrim($serverSpec['path'], '/').'/';

        $pathsThatExist = array();

        $connection = @ftp_connect($serverSpec['host'], $serverSpec['port']);

        if ($connection) {
            if (! ftp_login($connection, $serverSpec['user'], $serverSpec['pass'])) {
                throw new Exception("Oh Snap: Could not login to {$serverSpec['host']} (Tried to login as {$serverSpec['user']}).\n");
            }

            ftp_pasv($connection, $serverSpec['passive']);

            if (@ftp_chdir($connection, $serverSpec['path'])) {
                $this->connection = $connection;
                PHPloy::output("\r\n+ ---------- ".OUTPUT_SMILE." ---------- +");
                return true;
            } else {
                throw new Exception("Oh Snap: Could not change the FTP directory to {$serverSpec['path']}.\n");
            }
        } else {
            throw new Exception("Oh Snap: Could not connect to {$serverSpec['host']}\n");
        }
    }

    public function pwd()
    {
        return ftp_pwd($this->connection);
    }

    public function chdir($dir)
    {
        return ftp_chdir($this->connection, $dir);
    }

    public function mkdir($name)
    {
        return ftp_mkdir($this->connection, $name);
    }

    public function ls($dir)
    {
        return ftp_nlist($this->connection, $dir);
    }

    public function get($remoteFile, $localFile, $binaryTransfer=true)
    {
        if (is_resource($localFile)) {
            return ftp_fget($this->connection, $localFile, $remoteFile, ($binaryTransfer) ? FTP_BINARY : FTP_ASCII);
        } else {
            return ftp_get($this->connection, $localFile, $remoteFile, ($binaryTransfer) ? FTP_BINARY : FTP_ASCII);
        }
    }

    public function put($localFile, $remoteFile, $binaryTransfer=true)
    {
        return ftp_put($this->connection, $remoteFile, $localFile, ($binaryTransfer) ? FTP_BINARY : FTP_ASCII);
    }

    public function delete($remoteFile)
    {
        return ftp_delete($this->connection, $remoteFile);
    }

    public function disconnect()
    {
        return ftp_close($this->connection);
    }
}

class PHPloy_File implements PHPloy_protocol
{
    private $currentDir = null;

    public function connect(array $serverSpec)
    {
        // Make sure the $path ends with a slash.
        $serverSpec['path'] = rtrim($serverSpec['path'], '/').'/';

        if (is_dir($serverSpec['path']) && scandir($serverSpec['path'])) {
            $this->currentDir = $serverSpec['path'];
            PHPloy::output("\r\n+ ---------- ".OUTPUT_SMILE." ---------- +");
            return true;
        } else {
            throw new Exception("Oh Snap: Could not access the local server directory {$serverSpec['path']}.\n");
        }
    }

    public function pwd()
    {
        PHPloy::output("pwd(): " . realpath($this->currentDir));
        return realpath($this->currentDir);
    }

    private function isPathAbsolute($path) {
        switch (substr($path, 0, 1)) {
            case '/':
            case '\\':
                return true;
        }
        if (IS_WINDOWS) {
            switch (substr($path, 1, 2)) {
                case ':/':
                case ':\\':
                    return true;
            }
        }
        return false;
    }

    private function resolvePath($path) {
        if (!$this->isPathAbsolute($path)) {
            $path = $this->currentDir . '/' . $path;
        }

        $path = PHPloy::normalisePathForGit($path);

        $path = str_replace(array('/./', '//'), '/', $path);
        return $path;
    }

    public function chdir($dir)
    {
        PHPloy::output("chdir($dir)");
        $dir = $this->resolvePath($dir);

        if (is_dir($dir) && scandir($dir)) {
            PHPloy::output("~chdir($dir)");
            $this->currentDir = $dir;
            return true;
        } else {
            PHPloy::output("!!~chdir($dir)");
            return false;
        }
    }

    public function mkdir($name)
    {
        PHPloy::output("mkdir($name)");
        $name = $this->resolvePath($name);
        PHPloy::output("~mkdir($name)");
        return mkdir($name);
    }

    public function ls($dir)
    {
        PHPloy::output("ls($dir)");
        $dir = $this->resolvePath($dir);
        PHPloy::output("~ls($dir)");
        return scandir($dir);
    }

    public function get($remoteFile, $localFile, $binaryTransfer=true)
    {
        PHPloy::output("get($remoteFile, $localFile) [{$this->currentDir}]");
        $remoteFile = $this->resolvePath($remoteFile);
        PHPloy::output("~get($remoteFile, $localFile) [{$this->currentDir}]");

        if (is_resource($localFile)) {
            if ($fp = fopen($remoteFile, 'rb')) {
                return stream_copy_to_stream($fp, $localFile);
            } else {
                trigger_error("Unable to read remote file '$remoteFile'!", E_USER_WARNING);
                return false;
            }
        } else {
            return copy($remoteFile, $localFile);
        }
    }

    public function put($localFile, $remoteFile, $binaryTransfer=true)
    {
        PHPloy::output("put($localFile, $remoteFile) [{$this->currentDir}]");
        $remoteFile = $this->resolvePath($remoteFile);
        PHPloy::output("~put($localFile, $remoteFile) [{$this->currentDir}]");
        return copy($localFile, $remoteFile);
    }

    public function delete($remoteFile)
    {
        PHPloy::output("delete($remoteFile)");
        $remoteFile = $this->resolvePath($remoteFile);
        PHPloy::output("~delete($remoteFile)");
        return unlink($remoteFile);
    }

    public function disconnect()
    {
        return true;
    }
}

/**
 * PHPloy Class
 */
class PHPloy
{

    /**
     * @var string $revision
     */
    public $revision;

    /**
     * @var array $filesToIgnore
     */
    public $filesToIgnore = array('.gitignore', '.gitmodules', '.htaccess', '.htpasswd');

    /**
     * @var array $servers
     */
    public $servers = array();

    /**
     * @var array $submodules
     */
    public $submodules = array();

    /**
     * @var string $shortops
     */
    protected $shortopts  = 'ls:';

    /**
     * @var array $longopts
     */
    protected $longopts  = array('list', 'rollback::', 'server:', 'sync::');

    /**
     * @var PHPloy_FTP $connection
     */
    protected $connection = false;

    /**
     * @var string $server
     */
    protected $server = '';

    /**
     * @var string $repo
     */
    protected $repo;

    /**
     * @var string $mainRepo
     */
    protected $mainRepo;

    /**
     * @var bool|string $isSubmodule
     */
    protected $isSubmodule = false;

    /**
     * @var string $dotRevision
     */
    protected $dotRevision = '.revision';

    /**
     * @var bool $listFiles
     */
    protected $listFiles = false;

    /**
     * @var bool $listFiles
     */
    protected $sync = false;

    /**
     * Constructor
     */
    public function __construct()
    {
        $this->parseOptions();

        if (file_exists("{$this->repo}/.git")) {
            $this->checkSubmodules($this->repo);
            $this->deploy($this->revision);
        } else {
            throw new Exception("Oh Snap: '{$this->repo}' is not Git repository.\n");
        }
    }

    /**
     * Parse CLI options
     */
    protected function parseOptions()
    {
        $options = getopt($this->shortopts, $this->longopts);

        if (isset($options['l']) or isset($options['list'])) {
            $this->listFiles = true;
        }

        if (isset($options['s']) or isset($options['server'])) {
            $this->server = isset($options['s']) ? $options['s'] : $options['server'];
        }

        if (isset($options['sync'])) {
            $this->sync = empty($options['sync']) ? 'sync' : $options['sync'];
        }

        if (isset($options['rollback'])) {
            $this->revision = ($options['rollback'] == '') ? 'HEAD^' : $options['rollback'];
        } else {
            $this->revision = 'HEAD';
        }

        $this->repo = isset($opts['repo']) ? rtrim($opts['repo'], '/\\') : getcwd();
        $this->mainRepo = $this->repo;

        $this->repo = self::normalisePathForGit($this->repo);
    }

    public static function normalisePathForGit($path) {
        if (DIRECTORY_SEPARATOR == '\\') {
            // Need to normalise this because git doesn't like backslashes in paths... =/
            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);
        }
        return $path;
    }

    /**
     * Check for submodules
     *
     * @param string $repo
     */
    protected function checkSubmodules($repo)
    {
        $command = sprintf("git --git-dir=%s --work-tree=%s submodule status",
            escapeshellarg("$repo/.git"),
            escapeshellarg($repo));
        $output = array();

        self::output("#~ $command");
        exec(escapeshellcmd($command), $output);

        if (count($output) > 0) {
            foreach ($output as $line) {
                $line = explode(' ', trim($line));
                $this->submodules[] = array('revision' => $line[0], 'name' => $line[1], 'path' => $repo.'/'.$line[1]);
                $this->filesToIgnore[] = $line[1];
                $this->checkSubSubmodules($repo, $line[1]);
            }
        }
    }

    /**
     * Check for sub-submodules
     *
     * @param string $repo
     * @param string $name
     */
    protected function checkSubSubmodules($repo, $name)
    {
        $command = sprintf("git --git-dir=%s --work-tree=%s submodule foreach git submodule status",
            escapeshellarg("$repo/.git"),
            escapeshellarg($repo));
        $output = array();

        self::output("#~ $command");
        exec(escapeshellcmd($command), $output);

        if (count($output) > 0) {
            foreach ($output as $line) {
                $line = explode(' ', trim($line));

                if (trim($line[0]) == 'Entering') continue;

                $this->submodules[] = array('revision' => $line[0], 'name' => $name.'/'.$line[1], 'path' => $repo.'/'.$name.'/'.$line[1]);
                $this->filesToIgnore[] = $line[1];
            }
        }
    }

    /**
     * Parse Credentials
     *
     * @param string $deploy
     */
    protected function parseCredentials($deploy)
    {
        if (! file_exists($deploy)) {
            throw new Exception("Oh Snap: '$deploy' does not exist.\n");
        } else {
            $servers = parse_ini_file($deploy, true);

            if (! $servers) {
                 throw new Exception("Oh Snap: '$deploy' is not a valid .ini file.\n");
            } else {
                $this->filesToIgnore[] = $deploy;
                return $servers;
            }
        }
    }

    /**
     * Add Servers
     */
    protected function prepareServers()
    {
        $defaults = array(
            'scheme' => 'ftp',
            'host' => '',
            'user' => '',
            'pass' => '',
            'port' => 21,
            'path' => '/',
            'passive' => true,
            'clean_directories' => array()
        );

        $servers = $this->parseCredentials('deploy.ini');

        foreach ($servers as $name => $options) {
            if ($name == 'quickmode') {
                foreach ($options as $env => $creds) {
                    $options = parse_url($creds);
                    $options = array_merge($defaults, $options);
                    $this->servers[$env] = $options;
                }
                break;
            }

            $options = array_merge($defaults, $options);

            $this->servers[$name] = $options;
        }
    }

    /**
     * Compare revisions and return files to upload
     *
     * @param string $localRevision
     * @return array
     * @throws Exception if unknown git diff status
     */
    protected function compare($localRevision)
    {
        $remoteRevision = null;
        $tmpFile = tmpfile();
        $filesToUpload = array();
        $filesToDelete = array();
        $output = array();

        if ($this->isSubmodule) {
            $this->dotRevision = $this->isSubmodule.'/.revision';
        }

        if (@$this->connection->get($this->dotRevision, $tmpFile, false)) {
            fseek($tmpFile, 0);
            $remoteRevision = trim(fread($tmpFile, 1024));
            fclose($tmpFile);
        } else {
            self::output('Fresh deployment - grab a '.OUTPUT_COFFEE);
        }

        $gitCommand = sprintf("git --git-dir=%s --work-tree=%s",
            escapeshellarg("{$this->repo}/.git"),
            escapeshellarg($this->repo));

        if (empty($remoteRevision)) {
            $command = $gitCommand.' ls-files';
        } else if ($localRevision == 'HEAD') {
            $command = $gitCommand.' diff --name-status '.$remoteRevision.'...'.$localRevision;
        } else {
            $command = $gitCommand.' diff --name-status '.$remoteRevision.'... '.$localRevision;
        }

        self::output("#~ $command");
        exec(escapeshellcmd($command), $output);

        if (! empty($remoteRevision)) {
            foreach ($output as $line) {
                if ($line[0] == 'A' or $line[0] == 'C' or $line[0] == 'M') {
                    // Added (A), Modified (C), Unmerged (M)
                    $filesToUpload[] = trim(substr($line, 1));
                } elseif ($line[0] == 'D') {
                    // Deleted (D)
                    $filesToDelete[] = trim(substr($line, 1));
                } else {
                    throw new Exception("Oh Snap: Unknown git-diff status: {$line[0]}");
                }
            }
        } else {
            $filesToUpload = $output;
        }

        $filesToUpload = array_diff($filesToUpload, $this->filesToIgnore);

        return array(
            'upload' => $filesToUpload,
            'delete' => $filesToDelete
        );
    }

    /**
     * Deploy files
     *
     * @param string $revision
     */
    public function deploy($revision = 'HEAD')
    {
        $this->prepareServers();

        foreach ($this->servers as $name => $server) {
            // Skip servers not specified, if specified.
            if ($this->server != '' && $this->server != $name) continue;

            $this->connect($server);

            if( $this->sync ) {
                $this->setRevision();
                continue;
            }

            $files = $this->compare($revision);

            if ($this->listFiles === true) {
                self::output("SERVER ".OUTPUT_ARROW_RIGHT." ".$name);
                $this->listFiles($files);
            } else {
                self::output("SERVER ".OUTPUT_ARROW_RIGHT." ".$name);
                $this->push($files);
            }

            if (count($this->submodules) > 0) {
                foreach ($this->submodules as $submodule) {
                    $this->repo = $submodule['path'];
                    $this->isSubmodule = $submodule['name'];

                    self::output("SUBMODULE: ".$this->isSubmodule);

                    $files = $this->compare($revision);

                    if ($this->listFiles === true) {
                        $this->listFiles($files);
                    } else {
                        $this->push($files);
                    }
                }
            }

            $this->connection->disconnect();
        }
    }

    /**
     * Check what files will be uploaded/deleted
     *
     * @param array $files
     */
    protected function listFiles($files)
    {
        if (count($files['upload']) > 0 && count($files['delete']) > 0) {
            self::output("No files to upload.");
        }

        if (count($files['upload']) > 0) {
            self::output("Files to upload:");

            foreach ($files['upload'] as $file_to_upload) {
                self::output(" ".OUTPUT_ARROW_UP." ".$file_to_upload);
            }
        }

        if (count($files['delete']) > 0) {
            self::output("Files to delete:");

            foreach ($files['delete'] as $file_to_delete) {
                self::output(" ".OUTPUT_CROSS." ".$file_to_delete);
            }
        }
    }

    /**
     * Connect to the Server
     *
     * @param string $server
     * @throws Exception if it can't connect to FTP server
     * @throws Exception if it can't login to FTP server
     * @throws Exception if it can't change FTP directory
     */
    protected function connect($server)
    {
        $connection = null;
        $scheme = strtolower(isset($server['scheme']) ? $server['scheme'] : '');
        switch ($scheme) {
            case 'ftp':
            // An empty scheme defaults to FTP (but non-empty strings do NOT, in order to avoid confusion if someone
            //  typos 'SMB' and wonders why FTP is suddenly being used...)
            case '':
                $connection = new PHPloy_FTP();
                break;
            case 'file':
                $connection = new PHPloy_File();
                break;
            case 'smb':
                $connection = new PHPloy_SMB();
                break;
            default:
                throw new Exception("Unrecognised server scheme `$scheme`.");
        }

        if ($connection) {
            if ($connection->connect($server)) {
                $this->connection = $connection;
            }
        }
    }

    /**
     * Push Files one by one.
     */
    protected function push($files)
    {
        // If revision is not HEAD, the current one, it means this is a rollback.
        // So, we have to revert the files the the state they were in that revision.
        if ($this->revision != 'HEAD') {
            self::output(OUTPUT_ROLLBACK." Rolling back");
            $command = sprintf("git --git-dir=%s --work-tree=%s checkout %s",
                escapeshellarg("{$this->repo}/.git"),
                escapeshellarg($this->repo),
                $this->revision);
            self::output("#~ $command");
            exec(escapeshellcmd($command));
        }

        $filesToUpload = $files['upload'];
        $filesToDelete = $files['delete'];
        unset($files);

        foreach ($filesToUpload as $file) {
            if ($this->isSubmodule) $file = $this->isSubmodule.'/'.$file;

            // Make sure the folder exists in the server.
            $dir = explode("/", dirname($file));
            $path = "";
            $ret = true;

            for($i = 0, $count = count($dir); $i < $count; $i++) {
                $path .= $dir[$i].'/';

                if (! isset($pathsThatExist[$path])) {
                    $origin = $this->connection->pwd();

                    if (! @$this->connection->chdir($path)) {
                        if (! $this->connection->mkdir($path)) {
                            $ret = false;

                            self::output("Failed to create '$path'.");
                            self::output("Directory could not be created. Please check if a file with the same name exists in the server and delete it.");

                            return;
                        } else {
                            self::output("Created directory '$path'.");
                            $pathsThatExist[$path] = true;
                        }
                    } else {
                        $pathsThatExist[$path] = true;
                    }

                    @$this->connection->chdir($origin);
                }
            }

            $uploaded = false;
            $attempts = 1;

            while (! $uploaded) {
                if ($attempts == 10) {
                    throw new Exception("Oh Snap: Tried to upload $file 10 times and failed. Something is wrong ...\n");
                }

                $uploaded = $this->connection->put($file, $file, true);

                if (! $uploaded) {
                    $attempts = $attempts + 1;
                    self::output("Failed to upload {$file}. Retrying (attempt $attempts/10)... ");
                }
            }

            self::output(OUTPUT_TICK." \033[01;37m{$file}\033[0m \033[0;32muploaded\033[0m");
        }

        foreach ($filesToDelete as $file) {
            $this->connection->delete($file);
            self::output(OUTPUT_TICK." \033[01;37m{$file}\033[0m \033[01;31mremoved\033[0m");
        }

        if (! empty($server['clean_directories'])) {
            foreach ($server['clean_directories'] as $dir) {
                if (! $tmpFiles = $this->connection->ls($dir)) {
                    self::output("{$dir} already empty");
                    continue;
                }

                foreach ($tmpFiles as $file) {
                    $this->connection->delete($file);
                }

                self::output(OUTPUT_TICK." \033[01;37m{$dir}\033[0m \033[01;31memptied\033[0m");
            }
        }

        if (count($filesToUpload) > 0 or count($filesToDelete) > 0) {
            // Set revision on server
            $this->setRevision();
        } else {
            self::output("No files to upload.");
        }

        // If revision is not HEAD, the current one, it means this is a rollback.
        // So, we have to revert the master because we reverted to an earlier
        // revision before the deploy start.
        if ($this->revision != 'HEAD') {
            $command = sprintf("git --git-dir=%s --work-tree=%s checkout master",
                escapeshellarg("{$this->repo}/.git"),
                escapeshellarg($this->repo));
            self::output("#~ $command");
            exec(escapeshellcmd($command));
        }
    }

    /**
     * Sets version hash on the server.
     *
     */
    protected function setRevision()
    {
        if ( $this->sync == 'sync' or $this->sync == false ) {
            $command = sprintf("git --git-dir=%s --work-tree=%s rev-parse HEAD",
                escapeshellarg("{$this->repo}/.git"),
                escapeshellarg($this->repo));
            self::output("#~ $command");
            exec(escapeshellcmd($command), $locRev);
        } else {
            $locRev = $this->sync;
        }

        $temp = tempnam(sys_get_temp_dir(), 'gitRevision');
        file_put_contents($temp, $locRev);

        if ($this->connection->put($temp, $this->dotRevision, true)) {
            unlink($temp);
            if( $this->sync ) self::output("⟲ revision synced");
            self::output("+ ---------- ".OUTPUT_TICK." ---------- +\r\n");
        } else {
            throw new Exception("Oh Snap: Could not update the revision file on server.");
        }
    }

    /**
     * Helper method to display messages on the screen.
     *
     * @param string $message
     */
    public static function output($message) {
        if (IS_WINDOWS) {
            // Strip the ANSI colour codes if we're on Windows...
            // ("✓ \033[01;37m{$dir}\033[0m \033[01;31memptied\033[0m");
            $message = preg_replace('/
                \e
                (
                    \[[\x20-\x3F]+[\x40-\x7E]
                    |
                    [\x40-\x5F]
                )
            /x', '', $message);
        }

        echo $message."\r\n";
    }

}

try {
    $phploy = new PHPloy();
} catch (Exception $e) {
     echo $e->getMessage();
}

/*class PHPloy_SMB implements PHPloy_protocol
{
    public function connect(array $serverSpec)
    {
        // Make sure the $path ends with a slash.
        $serverSpec['path'] = rtrim($serverSpec['path'], '/').'/';

        $pathsThatExist = array();

        $connection = @ftp_connect($serverSpec['host'], $serverSpec['port']);

        if ($connection) {
            if (! ftp_login($connection, $serverSpec['user'], $serverSpec['pass'])) {
                throw new Exception("Oh Snap: Could not login to {$serverSpec['host']} (Tried to login as {$serverSpec['user']}).\n");
            }

            ftp_pasv($connection, $serverSpec['passive']);

            if (@ftp_chdir($connection, $serverSpec['path'])) {
                $this->connection = $connection;
                PHPloy::output("\r\n+ ---------- ".OUTPUT_SMILE." ---------- +");
                return true;
            } else {
                throw new Exception("Oh Snap: Could not change the FTP directory to {$serverSpec['path']}.\n");
            }
        } else {
            throw new Exception("Oh Snap: Could not connect to {$serverSpec['host']}\n");
        }
    }

    public function pwd()
    {
        return ftp_pwd($this->connection);
    }

    public function chdir($dir)
    {
        return ftp_chdir($this->connection, $dir);
    }

    public function mkdir($name)
    {
        return ftp_mkdir($this->connection, $name);
    }

    public function ls($dir)
    {
        return ftp_nlist($this->connection, $dir);
    }

    public function get($remoteFile, $localFile, $binaryTransfer=true)
    {
        return ftp_fget($this->connection, $localFile, $remoteFile, ($binaryTransfer) ? FTP_BINARY : FTP_ASCII);
    }

    public function put($localFile, $remoteFile, $binaryTransfer=true)
    {
        return ftp_put($this->connection, $remoteFile, $localFile, ($binaryTransfer) ? FTP_BINARY : FTP_ASCII);
    }

    public function delete($remoteFile)
    {
        return ftp_delete($this->connection, $remoteFile);
    }

    public function disconnect()
    {
        return ftp_close($this->connection);
    }
}*/